using Microsoft.Xna.Framework.Graphics;
using TexturePackerLoader;

namespace Color_it.game
{
    /// <summary>
    ///     Класс содержащий в себе три объекта архитектурного паттерна "Модель Отоброжение Контроллер".
    /// </summary>
    public abstract class ModelViewController
    {
        /// <summary>
        ///     Конструктор требующий назначения модели, отображения и контроллера.
        /// </summary>
        protected ModelViewController(IModel model, IView view, IController controller)
        {
            Model = model;
            View = view;
            Controller = controller;
        }

        /// <summary>
        ///     Модель
        /// </summary>
        public IModel Model { get; }

        /// <summary>
        ///     Отображение
        /// </summary>
        public IView View { get; }

        /// <summary>
        ///     Контроллер
        /// </summary>
        public IController Controller { get; }
    }

    /// <summary>
    ///     Интерфейс модели.
    /// </summary>
    /// @details Модель содержит в себе данные реализуемого объекта.
    /// @warning Модели не следует изменяться и визуализироваться самостоятельно.
    /// @note Важно понимать разницу между моделью и отображением!
    /// Модель не должна хранить в себе данные отображения, такие как размеры поля, игровых объектов и т.д.
    /// В случае если реализация использует координаты, не стоит ни коим образом использовать для этого данные отображения.
    /// Т.е. не нужно ограничивать игровое пространство размерами окна отображения.
    /// @noop П.с. Боже мой! Как жаль, что нельзя вписывать в документацию подобное повествование!
    /// @noop Короче, ваше поле может быть хоть 1000000 на 3000000, и это не значит что та же змейка будет за экраном.
    /// @noop Ещё чуть разжую, представьте огромный график функции. От -100 до 100 по X и Y, в модели у точек шаг 0.001, но отображается он с шагом в 5. Понятно?
    /// @noop Если вы так и не поняли, спросите меня лично, объясню ещё как нибудь.
    /// @noop И да, игр с сеткой это тоже касается! У вас сетка! используйте вершины == node.
    public interface IModel
    {
    }


    /// <summary>
    /// Интерфейс контроллера.
    /// </summary>
    /// @details Контроллер отвечает за обновление данных модели и взаимодействие с пользователем.
    /// @warning Контроллер не должен напрямую влиять на отображение!
    public interface IController
    {
        /// <summary>
        ///     Метод обновления.
        ///     В среднем вызывается 60 раз в секунду.
        /// </summary>
        /// <param name="delta">Время прошедшее с последнего обновления</param>
        void Update(float delta);

        /// <summary>
        /// Вызывается единожды перед запуском игры
        /// </summary>
        /// @details Данный метод используется для инициализации при необходимости.
        /// @noop П.с. используйте этот метод если вы чтьо-то не можете инициализировать в конструкторе модели 
        void OnBegin();

        /// <summary>
        /// Вызывается при возобновлении игры
        /// </summary>
        /// @details Вызывается каждый раз при возобновлении игры.
        void OnResume();

        /// <summary>
        /// Вызывается при приостановке игры
        /// </summary>
        /// @details Вызывается каждый раз при приостановке игры.
        void OnPause();

        /// <summary>
        /// Вызывается единожды при завершении игры
        /// </summary>
        /// @details Данный метод используется для утилизации модели при необходимости.
        void OnEnd();
    }

    /// <summary>
    ///     Интерфейс отображения.
    /// </summary>
    /// @details Отображение выводит данные модели на экран пользователя
    /// @warning Отображение не должно влиять на модель!
    public interface IView
    {
        /// <summary>
        ///     Метод отрисовки.
        ///     В среднем вызывается 60 раз в секунду.
        /// </summary>
        /// <param name="batch">Упаковщик спрайтов. Используется для отрисовки</param>
        /// <param name="render">Визуализатор для спрайтов</param>
        void Draw(SpriteBatch batch, SpriteRender render);
    }

    /// <summary>
    ///     Класс метка для миниигр. Необходим для предотвращения попытки присвоения основной игры в качестве миниигры.
    /// </summary>
    public abstract class SubGame : ModelViewController
    {
        protected SubGame(IModel model, IView view, IController controller) : base(model, view, controller)
        {
        }
    }
}